{"version":3,"file":"KotlinGameJam.js","sources":["../../../../../klock/src/commonMain/kotlin/com/soywiz/klock/TimeSpan.kt","../../../../../korge/src/commonMain/kotlin/com/soywiz/korge/view/Text.kt","../../../../../korge/src/commonMain/kotlin/com/soywiz/korge/view/SolidRect.kt","../../../../../korge/src/commonMain/kotlin/com/soywiz/korge/input/MouseEvents.kt","kotlin/math.kt","../../../../../src/commonMain/kotlin/entities/Player.kt","../../../../../kmem/src/commonMain/kotlin/com/soywiz/kmem/Numbers.kt","../../../../../src/commonMain/kotlin/gameStateManager/GameDependency.kt","../../../../../src/commonMain/kotlin/gameStateManager/scenes/GameScene.kt","../../../../../korge/src/commonMain/kotlin/com/soywiz/korge/scene/SceneContainer.kt","util/Standard.kt","../../../../../src/commonMain/kotlin/gameStateManager/scenes/MainMenuScene.kt","../../../../../src/commonMain/kotlin/main.kt","../../../../../korinject/src/commonMain/kotlin/com/soywiz/korinject/AsyncInjector.kt","../../../../../src/commonMain/kotlin/math/Perlin.kt","arrayUtils.kt"],"sourcesContent":[null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n",null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n",null,null,null,null,null],"names":[],"mappings":"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"}